diff --git a/src/latexify/codegen/expression_codegen_test.py b/src/latexify/codegen/expression_codegen_test.py
index 5eb999b..b6b742e 100644
--- a/src/latexify/codegen/expression_codegen_test.py
+++ b/src/latexify/codegen/expression_codegen_test.py
@@ -1084,3 +1084,174 @@ def test_remove_multiply(left: str, right: str, latex: str) -> None:
             expression_codegen.ExpressionCodegen(use_math_symbols=True).visit(tree)
             == latex
         )
+
+
+@pytest.mark.parametrize(
+    "code,latex",
+    [
+        ("det(A)", r"\det \mathopen{}\left( \mathbf{A} \mathclose{}\right)"),
+        ("det(b)", r"\det \mathopen{}\left( \mathbf{b} \mathclose{}\right)"),
+        (
+            "det([[1, 2], [3, 4]])",
+            r"\det \mathopen{}\left( \begin{bmatrix} 1 & 2 \\"
+            r" 3 & 4 \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "det([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
+            r"\det \mathopen{}\left( \begin{bmatrix} 1 & 2 & 3 \\"
+            r" 4 & 5 & 6 \\"
+            r" 7 & 8 & 9 \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "det([[a, b], [c, d]])",
+            r"\det \mathopen{}\left( \begin{bmatrix} a & b \\"
+            r" c & d \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "det(C @ D)",
+            r"\det \mathopen{}\left( \mathbf{C} \mathbf{D} \mathclose{}\right)",
+        ),
+        (
+            "det(transpose(E))",
+            r"\det \mathopen{}\left( \mathbf{E}^{\mathrm{T}} \mathclose{}\right)",
+        ),
+        (
+            "det(np.array([[1, 2], [3, 4]]))",
+            r"\det \mathopen{}\left( \begin{bmatrix} 1 & 2 \\"
+            r" 3 & 4 \end{bmatrix} \mathclose{}\right)",
+        ),
+    ],
+)
+def test_call_determinant(code: str, latex: str) -> None:
+    tree = ast_utils.parse_expr(code)
+    assert isinstance(tree, ast.Call)
+    assert expression_codegen.ExpressionCodegen().visit(tree) == latex
+
+
+@pytest.mark.parametrize(
+    "code,latex",
+    [
+        ("trace(A)", r"\mathrm{tr} \mathopen{}\left( \mathbf{A} \mathclose{}\right)"),
+        ("trace(b)", r"\mathrm{tr} \mathopen{}\left( \mathbf{b} \mathclose{}\right)"),
+        (
+            "trace([[1, 2], [3, 4]])",
+            r"\mathrm{tr} \mathopen{}\left( \begin{bmatrix} 1 & 2 \\"
+            r" 3 & 4 \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
+            r"\mathrm{tr} \mathopen{}\left( \begin{bmatrix} 1 & 2 & 3 \\"
+            r" 4 & 5 & 6 \\"
+            r" 7 & 8 & 9 \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "trace([[a, b], [c, d]])",
+            r"\mathrm{tr} \mathopen{}\left( \begin{bmatrix} a & b \\"
+            r" c & d \end{bmatrix} \mathclose{}\right)",
+        ),
+        (
+            "trace(C @ D)",
+            r"\mathrm{tr} \mathopen{}\left( \mathbf{C} \mathbf{D} \mathclose{}\right)",
+        ),
+        (
+            "trace(transpose(E))",
+            r"\mathrm{tr} \mathopen{}\left( \mathbf{E}^{\mathrm{T}} \mathclose{}\right)",
+        ),
+        (
+            "trace(np.array([[1, 2], [3, 4]]))",
+            r"\mathrm{tr} \mathopen{}\left( \begin{bmatrix} 1 & 2 \\"
+            r" 3 & 4 \end{bmatrix} \mathclose{}\right)",
+        ),
+    ],
+)
+def test_call_trace(code: str, latex: str) -> None:
+    tree = ast_utils.parse_expr(code)
+    assert isinstance(tree, ast.Call)
+    assert expression_codegen.ExpressionCodegen().visit(tree) == latex
+
+
+@pytest.mark.parametrize(
+    "code,latex",
+    [
+        ("inv(A)", r"\mathbf{A}^{-1}"),
+        ("inv(b)", r"\mathbf{b}^{-1}"),
+        (
+            "inv([[1, 2], [3, 4]])",
+            r"\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}^{-1}",
+        ),
+        (
+            "inv([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
+            r"\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{bmatrix}^{-1}",
+        ),
+        (
+            "inv([[a, b], [c, d]])",
+            r"\begin{bmatrix} a & b \\ c & d \end{bmatrix}^{-1}",
+        ),
+        (
+            "inv(C @ D)",
+            r"\left( \mathbf{C} \mathbf{D} \right)^{-1}",
+        ),
+        (
+            "inv(transpose(E))",
+            r"\left( \mathbf{E}^{\mathrm{T}} \right)^{-1}",
+        ),
+        (
+            "inv(np.array([[1, 2], [3, 4]]))",
+            r"\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}^{-1}",
+        ),
+    ],
+)
+def test_call_inv(code: str, latex: str) -> None:
+    tree = ast_utils.parse_expr(code)
+    assert isinstance(tree, ast.Call)
+    assert expression_codegen.ExpressionCodegen().visit(tree) == latex
+
+
+@pytest.mark.parametrize(
+    "code,latex",
+    [
+        ("norm(A)", r"\left\| \mathbf{A} \right\|"),
+        ("norm(b)", r"\left\| \mathbf{b} \right\|"),
+        (
+            "norm([[1, 2], [3, 4]])",
+            r"\left\| \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \right\|",
+        ),
+        (
+            "norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
+            r"\left\| \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{bmatrix} \right\|",
+        ),
+        (
+            "norm([[a, b], [c, d]])",
+            r"\left\| \begin{bmatrix} a & b \\ c & d \end{bmatrix} \right\|",
+        ),
+        (
+            "norm(C @ D)",
+            r"\left\| \mathbf{C} \mathbf{D} \right\|",
+        ),
+        (
+            "norm(transpose(E))",
+            r"\left\| \mathbf{E}^{\mathrm{T}} \right\|",
+        ),
+        (
+            "norm(np.array([[1, 2], [3, 4]]))",
+            r"\left\| \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \right\|",
+        ),
+    ],
+)
+def test_call_norm(code: str, latex: str) -> None:
+    tree = ast_utils.parse_expr(code)
+    assert isinstance(tree, ast.Call)
+    assert expression_codegen.ExpressionCodegen().visit(tree) == latex
+
+
+@pytest.mark.parametrize(
+    "code,latex",
+    [
+        ("rank(A)", r"\mathrm{rank} \mathopen{}\left( \mathbf{A} \mathclose{}\right)"),
+        ("rank(b)", r"\mathrm{rank} \mathopen{}\left( \mathbf{b} \mathclose{}\right)"),
+    ],
+)
+def test_call_rank(code: str, latex: str) -> None:
+    tree = ast_utils.parse_expr(code)
+    assert isinstance(tree, ast.Call)
+    assert expression_codegen.ExpressionCodegen().visit(tree) == latex
